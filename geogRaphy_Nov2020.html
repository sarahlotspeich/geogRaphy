<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>geogRaphy: an introduction to spatial data in R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Sarah C. Lotspeich" />
    <meta name="date" content="2020-11-17" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# geogRaphy: an introduction to spatial data in R
### Sarah C. Lotspeich
### Vanderbilt University
### 17 Nov 2020

---






class: inverse, center, middle

# Introduction

---
class: center, middle

# spatial data:

### noun • [spay-shull day-ta] • data which is representative of a specific, geographic location on the surface of the Earth.

.footnote[
[1] [What Is Spatial Data?](https://www.safe.com/what-is/spatial-data/)
]

---
# Two main types:
.pull-left[
## 1. Vector data
  - Graphical representations of the real world.
  - Usually, points, lines, and polygons.
  - GIS shapefiles (`.shp`) are typically vector data.
]

.pull-right[
  ![](images/Vector.png)
]

.footnote[
[1] [Geospatial Data Models](http://gsp.humboldt.edu/OLM/Courses/GSP_216_Online/lesson3-1/data-models.html) 

[2] [What Is Spatial Data?](https://www.safe.com/what-is/spatial-data/)

[3] [Vector and Raster: A Tale of Two Spatial Data Types](https://www.vebuso.com/2019/01/vector-raster-tale-two-spatial-data-types/)
]

---
# Two main types:
.pull-left[
## 2. Raster data
  - Continuous surface divided into a grid of cells (pixels).
  - Each pixel contains measured value for the area it represents. 
  - One cell might represent a 10m x 10m area. 
]

.pull-right[
  ![](images/raster.png)
]

.footnote[
[1] [Geospatial Data Models](http://gsp.humboldt.edu/OLM/Courses/GSP_216_Online/lesson3-1/data-models.html) 

[2] [What Is Spatial Data?](https://www.safe.com/what-is/spatial-data/)

[3] [Vector and Raster: A Tale of Two Spatial Data Types](https://www.vebuso.com/2019/01/vector-raster-tale-two-spatial-data-types/)
]

---
# More than the "where"

  - Spatial data contain more than just location. 
  - Additional attributes can be tied to the observation based on its location. 
  - Non-spatial features are called **attributes**.
  - Example: New York City subway entrances.

.footnote[
[1] [What Is Spatial Data?](https://www.safe.com/what-is/spatial-data/)

[2] Data source: [City of New York Subway Entrances](https://data.world/city-of-ny/drex-xx56)
]

---

background-image: url("images/map1.png")
background-position: center
background-size: contain

---

background-image: url("images/map2.png")
background-position: center
background-size: contain

---

background-image: url("images/map3.png")
background-position: center
background-size: contain

---

class: inverse, center, middle

# Outline

---

# Today's game plan:

## 1. Geocoding

## 2. Distance calculations

## 3. Map-making

## 4. Point-in-polygon analysis

---

class: inverse, center, middle

# Geocoding

---
class: center, middle

### **Geocoding** is the process of converting addresses (like a street address) into geographic coordinates (like latitude and longitude), which you can use to place markers on a map, or position the map.

.footnote[
[1] [Google Maps Geocoding API](https://developers.google.com/maps/documentation/geocoding/start#:~:text=Geocoding%20is%20the%20process%20of,into%20a%20human%2Dreadable%20address.)
]

---
# Best practices

1. Remove suite/apartment numbers (they will simply create ties).
2. Be mindful of special characters like @, #, ?, etc. 
3. Check for misspellings or abbreviations. 
4. Prepare to spend some time cleaning addresses. 


```
##                                 original
## 1 310 25TH AVE S #103 NASHVILLE TN 37240
## 2 2301 VANDERBILT PLC NASHVILLE TN 37240
## 3   2400 BLAKMORE AVE NASHVILLE TN 37212
## 4    TWENTY 3RD AVE N NASHVILLE TN 37212
##                                 cleaned
## 1     310 25TH AVE S NASHVILLE TN 37240
## 2 2301 VANDERBILT PL NASHVILLE TN 37240
## 3 2400 BLAKEMORE AVE NASHVILLE TN 37212
## 4         23RD AVE N NASHVILLE TN 37212
```

.footnote[
[1] [Blossom (2014), Geocoding Best Practices](http://gis2.harvard.edu/services/blog/geocoding-best-practices)
]

---

# How it works

The algorithm begins by taking a complete street address and breaking it down into its component parts. 

**Example:** 2525 WEST END AVE NASHVILLE TN 37203

- **Street number:** 2525
- **Street name:** WEST END
- **Street type:** AVE
- **Street suffix direction:** 
- **City:** NASHVILLE
- **State:** TN
- **ZIP:** 37203

This address is then compared to a reference table that has already been mapped (e.g., GoogleMaps or TomTom).

.footnote[
[1] [Blossom (2014), Geocoding Best Practices](http://gis2.harvard.edu/services/blog/geocoding-best-practices)
]

---

# Level of accuracy

Often (but not always) geocoders can pinpoint exact property or building of the address input. When it cannot, a few things can happen: 

- a match at a less precise level

  *If 170 MAIN STREET, CLEVELAND, OH cannot be found in Cleveland, the address may be matched either with a 170 MAIN STREET in a nearby town or with the city center of CLEVELAND*

- address range interpolation along a street
  
  *170 MAIN STREET will be placed 70% of the way along the block of MAIN STREET that ranges from street numbers 100-200*

Most geocoders give a level of confidence or matching. You can also confirm matches visually!

.footnote[
[1] [Blossom (2014), Geocoding Best Practices](http://gis2.harvard.edu/services/blog/geocoding-best-practices)
]

---
# Example: Farmers Markets Directory and Geographic Data

State, address, name, and zip code of farmers markets in the United States, along with attributes such as payment methods accepted and types of goods for sale. 


```
##      fmid               street       city    county
## 1 1018261                        Danville Caledonia
## 2 1000709 71 Waterwitch Avenue  Highlands  Monmouth
## 3 1019846      110 W. Main St. West Union     Adams
##        state   zip
## 1    Vermont  5828
## 2 New Jersey  7732
## 3       Ohio 45693
```

Downloaded from the [US Department of Agriculture.](https://catalog.data.gov/dataset/farmers-markets-directory-and-geographic-data) Read it into `R`:


```r
p &lt;- "https://raw.githubusercontent.com/sarahlotspeich/geogRaphy/main/data/us_farmers_markets.csv"
farm &lt;- read.csv(p, stringsAsFactors = F)
```

---

# The `ggmap` package

*A collection of functions to visualize spatial data and models
on top of static maps from various online sources (e.g Google Maps and Stamen
Maps). It includes tools common to those tasks, including functions for
geolocation and routing.*

The `geocode()` function takes inputs:
  - `location`: a character vector of street addresses or place names 
  - `output`: amount of output 
      - `output = "latlon"` returns latitude/longitude 
      - `output = "latlona"` returns latitude/longitude + address 
      - `output = "more"` returns same as `"latlon"` + accuracy measures `type` and `loctype`
      - `output = "all"` returns same as `"more"` + many others
  - `source`: source of reference table to use (set `source = "google"`)

.footnote[
[1] [D. Kahle and H. Wickham. ggmap: Spatial Visualization with ggplot2. The R Journal, 5(1), 144-161.](https://journal.r-project.org/archive/2013-1/kahle-wickham.pdf)
]

---

# Setting up your API key

## Get a key
First, you'll need to register for a *free* Google Maps API key here: [https://cloud.google.com/maps-platform/](https://cloud.google.com/maps-platform/). 

## Register your key in `R`

```r
ggmap::register_google(key = "YOUR KEY")
```

You'll need to call the `register_google()` command everytime you open a new session. If you want to set it permanently, instead call:


```r
ggmap::register_google(key = "YOUR KEY", write = TRUE)
```

---
# Geocoding the US farmers market directory


```r
farm %&gt;% 
  mutate(address = paste(street, city, state, zip, sep = ", ")) %&gt;% 
  pull(address) %&gt;% 
  ggmap::geocode(output = "more", source = "google") -&gt; farm_geo
```




```
## # A tibble: 6 x 9
##      lon   lat type  loctype address north south   east
##    &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1  -89.5  34.4 stre… range_… 700 n …  34.4  34.4  -89.5
## 2 -105.   40.6 prem… rooftop 200 w …  40.6  40.6 -105. 
## 3  -87.8  41.8 prem… rooftop 10 pin…  41.8  41.8  -87.8
## 4 -105.   38.9 prem… rooftop 7350 p…  38.9  38.9 -105. 
## 5  -88.0  30.7 stre… rooftop 300 co…  30.7  30.7  -88.0
## 6  -90.3  42.4 stre… rooftop 2000 t…  42.4  42.4  -90.3
## # … with 1 more variable: west &lt;dbl&gt;
```

---

# Checking accuracy of `ggmap::geocode()`

The `type` and `loctype` outputs tell us about the geocoded match. Let's look at a few examples... 

Less precise matches:

- There were a couple of addresses that only gave city, state, and zip. These yielded `approximate` matches. 
- Others gave street, city, state, and zip, which were matched with `geometric_center`. 

More precise matches:
- Ideally, addresses would be either `rooftop` level matched or `range_interpolated`. 

---
# Manual check 

.pull-left[
**Address:** Westminster, MA, 01473

**Geocoded:** (42.5580692, -71.8927076)

&lt;img src="images/westminster_ma.png" width="55%" style="display: block; margin: auto;" /&gt;

]

.pull-right[
**Address:** Oak Ridge, OK, 74056

**Geocoded:** (36.8970141, -96.1130438)

&lt;img src="images/oak_ridge_ok.png" width="55%" style="display: block; margin: auto;" /&gt;
]

---

# Alternative function `ggmap::mutate_geocode()`

If you want to add latitude/longitude columns to your existing `farm` dataset, you can use `ggmap::mutate_geocode()`. It takes the address column as an input (`location = address`). 


```r
farm %&gt;% 
  mutate(address = paste(street, city, state, zip, sep = ", ")) %&gt;% 
  ggmap::mutate_geocode(location = address, source = "google") -&gt; farm
```

Now we have a dataset of 1368 farmers markets in the US with their geocoded locations as `(lat, lon)` coordinates.

---

class: inverse, center, middle

# Distance calculations

---
class: left, top
# Great-circle distance calculations

"The **great-circle distance**... is the shortest distance between two points on the surface of a sphere..." [(Wikipedia)](Wikipedia)

Given two `(lat, lon)` coordinates, there are two common options here:

1. Spherical Law of Cosines
2. Haversine Formula

Both calculations have been implemented in the `R` package `geosphere`. 

.footnote[
[1] [Great-circle distance calculations in R](https://www.r-bloggers.com/2010/11/great-circle-distance-calculations-in-r/)
]

---

# The `geosphere` package

*Spherical trigonometry for geographic applications. That is, compute distances and related measures for angular (longitude/latitude) locations.*

Functions `distHaversine()` and `distCosine()` take the same inputs: 

  - `p1` and `p2`: longitude/latitude of point(s)
  - `r`: radius of the earth (set `= 3958.8` for output in miles and `= 6378137` for output in meters)

and give individual distance calculations.

.footnote[
[1] [R. Hijmans. Introduction to the "geosphere” package](https://cran.r-project.org/web/packages/geosphere/vignettes/geosphere.pdf)
]

---

# The `geosphere` package

*Spherical trigonometry for geographic applications. That is, compute distances and related measures for angular (longitude/latitude) locations.*

The `distm()` function takes two sets of points (rather than two points) and returns a matrix of the distances between the sets. 

  - `x` and `y`: longitude/latitude of point(s). If `y` is null, `distm(x)` returns the pairwise distances between each point in `x`. 
  - `fun`: which function to use to compute distances (set `fun = distHaversine` or `fun = distCosine`)

**Note:** Since `distm()` does not have a `r` input, the output will always be in meters by default. 

.footnote[
[1] [R. Hijmans. Introduction to the "geosphere” package](https://cran.r-project.org/web/packages/geosphere/vignettes/geosphere.pdf)
]

---

# The `geosphere` package

*Spherical trigonometry for geographic applications. That is, compute distances and related measures for angular (longitude/latitude) locations.*

The `distm()` function takes two sets of points (rather than two points) and returns a matrix of the distances between the sets. 

  - `x` and `y`: longitude/latitude of point(s). If `y` is null, `distm(x)` returns the pairwise distances between each point in `x`. 
  - `fun`: which function to use to compute distances (set `fun = distHaversine` or `fun = distCosine`)

**Note:** Since `distm()` does not have a `r` input, the output will always be in meters by default. 

.footnote[
[1] [R. Hijmans. Introduction to the "geosphere” package](https://cran.r-project.org/web/packages/geosphere/vignettes/geosphere.pdf)
]

---

# Distance between two Knoxville farmers markets


```r
farm %&gt;% filter(fmid == 1019189) -&gt; fmid1019189
farm %&gt;% filter(fmid == 1019624) -&gt; fmid1019624
```

Use Haversine formula and Spherical Law of Cosines to find the distance (in miles):


```r
geosphere::distHaversine(p1 = fmid1019189[, c("lon", "lat")], 
                         p2 = fmid1019624[, c("lon", "lat")], 
                         r = 3958.8)
```

```
## [1] 1.300333
```

```r
geosphere::distCosine(p1 = fmid1019189[, c("lon", "lat")], 
                      p2 = fmid1019624[, c("lon", "lat")], 
                      r = 3958.8)
```

```
## [1] 1.300333
```

---

# Distance between all Knoxville farmers markets


```r
farm %&gt;% filter(city == "Knoxville", state == "Tennessee") -&gt; knx_fm
```

There are 4 farmers markets registered in Knoxville, TN. Look at the full 4  by 4 distance matrix for them all. 


```r
geosphere::distm(x = knx_fm[, c("lon", "lat")], 
                 fun = geosphere::distHaversine) * 0.000621371
```

```
##          [,1]      [,2]     [,3]      [,4]
## [1,] 0.000000 1.3017748 4.478106 1.2183703
## [2,] 1.301775 0.0000000 5.543254 0.8626713
## [3,] 4.478106 5.5432535 0.000000 4.8505622
## [4,] 1.218370 0.8626713 4.850562 0.0000000
```

The `* 0.000621371` transforms the matrix from meters to miles. 

---

class: center, middle
# Thank you! Any questions?

---
# References
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "solarized-dark",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
